package eu.nites.compressor.models.nayuki;
/*
 * Reference arithmetic coding
 * Copyright (c) Project Nayuki
 *
 * https://www.nayuki.io/page/reference-arithmetic-coding
 * https://github.com/nayuki/Reference-arithmetic-coding
 */

import eu.nites.compressor.models.Hash;

import java.io.*;
import java.util.Date;


/**
 * Decompression application using static arithmetic coding.
 * <p>Usage: java ArithmeticDecompress InputFile OutputFile</p>
 * <p>This decompresses files generated by the "ArithmeticCompress" application.</p>
 */
public class ArithmeticDecompress {

    private String filename;
    private String code;

    public ArithmeticDecompress(File inputFile) throws IOException {
        // Handle command line arguments
        if (!inputFile.isFile()) {
            System.err.println("Usage: java ArithmeticDecompress InputFile OutputFile");
            System.exit(1);
            return;
        }
        this.filename = "ar-decompress-" + (new Date().getTime() / 1000) + ".txt";
        this.code = inputFile.getName().split("-")[1].replaceFirst("[.][^.]+$", "");
        File outputFile = new File("./src/main/resources/static/storage/" + this.filename);

        // Perform file decompression
        try (BitInputStream in = new BitInputStream(new BufferedInputStream(new FileInputStream(inputFile)));
             OutputStream out = new BufferedOutputStream(new FileOutputStream(outputFile))) {
            FrequencyTable freqs = readFrequencies(in);
            decompress(freqs, in, out);
        }
    }

    public String getLink () {
        return this.filename;
    }

    public boolean checkHash () throws IOException {
        return Hash.check(this.filename, this.code);
    }


    // To allow unit testing, this method is package-private instead of private.
    static FrequencyTable readFrequencies(BitInputStream in) throws IOException {
        int[] freqs = new int[257];
        for (int i = 0; i < 256; i++)
            freqs[i] = readInt(in, 32);
        freqs[256] = 1;  // EOF symbol
        return new SimpleFrequencyTable(freqs);
    }


    // To allow unit testing, this method is package-private instead of private.
    static void decompress(FrequencyTable freqs, BitInputStream in, OutputStream out) throws IOException {
        ArithmeticDecoder dec = new ArithmeticDecoder(32, in);
        while (true) {
            int symbol = dec.read(freqs);
            if (symbol == 256)  // EOF symbol
                break;
            out.write(symbol);
        }
    }


    // Reads an unsigned integer of the given bit width from the given stream.
    private static int readInt(BitInputStream in, int numBits) throws IOException {
        if (numBits < 0 || numBits > 32)
            throw new IllegalArgumentException();

        int result = 0;
        for (int i = 0; i < numBits; i++)
            result = (result << 1) | in.readNoEof();  // Big endian
        return result;
    }

}